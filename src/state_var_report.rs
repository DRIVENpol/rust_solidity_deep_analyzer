use crate::models::*;
use std::collections::{HashMap, HashSet};

pub struct StateVarReportGenerator;

impl StateVarReportGenerator {
    /// Generate state variable access report for all contracts
    pub fn generate_report(contracts: &[ContractInfo]) -> String {
        let mut report = String::new();

        report.push_str("# State Variable Access Report\n\n");
        report.push_str("**Shows which functions read and write each state variable, including call chains**\n\n");

        for contract in contracts {
            report.push_str(&Self::generate_contract_section(contract, contracts));
        }

        report.push_str("\n---\n\n");
        report.push_str("*Generated by MainnetReady - Solidity Enhanced Analyzer*\n");

        report
    }

    /// Generate section for a single contract
    fn generate_contract_section(contract: &ContractInfo, _all_contracts: &[ContractInfo]) -> String {
        let mut section = String::new();

        section.push_str(&format!("## Contract: {}\n\n", contract.name));

        // Build call graph for this contract
        let call_graph = Self::build_call_graph(&contract.functions);

        // Process each state variable
        for state_var in &contract.state_variables {
            section.push_str(&Self::generate_state_var_section(
                state_var,
                &contract.functions,
                &call_graph,
                &contract.name,
            ));
        }

        section
    }

    /// Generate section for a single state variable
    fn generate_state_var_section(
        state_var: &StateVariable,
        functions: &[FunctionDef],
        call_graph: &HashMap<String, Vec<String>>,
        _contract_name: &str,
    ) -> String {
        let mut section = String::new();

        section.push_str(&format!("### State Variable: `{}`\n", state_var.name));
        section.push_str(&format!("**Type:** {}\n", state_var.var_type));
        section.push_str(&format!("**Visibility:** {}\n", state_var.visibility));
        if state_var.is_constant {
            section.push_str("**Constant:** yes\n");
        }
        if state_var.is_immutable {
            section.push_str("**Immutable:** yes\n");
        }
        section.push('\n');

        // Find writers
        let (direct_writers, indirect_writers) = Self::find_writers(
            &state_var.name,
            functions,
            call_graph,
        );

        // Find readers
        let (direct_readers, indirect_readers) = Self::find_readers(
            &state_var.name,
            functions,
            call_graph,
        );

        // Display writers
        section.push_str(&format!(
            "**WRITERS** ({} direct, {} total via call chains):\n",
            direct_writers.len(),
            direct_writers.len() + indirect_writers.len()
        ));

        if direct_writers.is_empty() && indirect_writers.is_empty() {
            section.push_str("   - None (read-only or constant)\n");
        } else {
            if !direct_writers.is_empty() {
                section.push_str("   *Direct:*\n");
                for func in &direct_writers {
                    let func_vis = Self::get_func_visibility(func, functions);
                    section.push_str(&format!("      - `{}`  *({})*\n", func, func_vis));
                }
            }

            if !indirect_writers.is_empty() {
                section.push_str("   *Via call chains:*\n");
                for (caller, chain) in &indirect_writers {
                    let func_vis = Self::get_func_visibility(caller, functions);
                    section.push_str(&format!("      - `{}` *({})* → {}\n",
                        caller, func_vis, chain.join(" → ")));
                }
            }
        }
        section.push('\n');

        // Display readers
        section.push_str(&format!(
            "**READERS** ({} direct, {} total via call chains):\n",
            direct_readers.len(),
            direct_readers.len() + indirect_readers.len()
        ));

        if direct_readers.is_empty() && indirect_readers.is_empty() {
            section.push_str("   - None (write-only or unused)\n");
        } else {
            if !direct_readers.is_empty() {
                section.push_str("   *Direct:*\n");
                for func in &direct_readers {
                    let func_vis = Self::get_func_visibility(func, functions);
                    section.push_str(&format!("      - `{}`  *({})*\n", func, func_vis));
                }
            }

            if !indirect_readers.is_empty() {
                section.push_str("   *Via call chains:*\n");
                for (caller, chain) in &indirect_readers {
                    let func_vis = Self::get_func_visibility(caller, functions);
                    section.push_str(&format!("      - `{}` *({})* → {}\n",
                        caller, func_vis, chain.join(" → ")));
                }
            }
        }

        section.push('\n');
        section
    }

    /// Find all functions that write to a state variable (direct and via call chains)
    fn find_writers(
        var_name: &str,
        functions: &[FunctionDef],
        call_graph: &HashMap<String, Vec<String>>,
    ) -> (Vec<String>, Vec<(String, Vec<String>)>) {
        let mut direct = Vec::new();
        let mut indirect = Vec::new();

        // Find direct writers
        for func in functions {
            if func.modifies_states.contains(&var_name.to_string())
                || func.modifies_state_fields.iter().any(|f| f.starts_with(&format!("{}.", var_name))) {
                direct.push(func.name.clone());
            }
        }

        // Find indirect writers (functions that call direct writers)
        for func in functions {
            if !direct.contains(&func.name) {
                if let Some(chain) = Self::find_call_chain_to_writers(&func.name, &direct, call_graph) {
                    indirect.push((func.name.clone(), chain));
                }
            }
        }

        (direct, indirect)
    }

    /// Find all functions that read from a state variable (direct and via call chains)
    fn find_readers(
        var_name: &str,
        functions: &[FunctionDef],
        call_graph: &HashMap<String, Vec<String>>,
    ) -> (Vec<String>, Vec<(String, Vec<String>)>) {
        let mut direct = Vec::new();
        let mut indirect = Vec::new();

        // Find direct readers
        for func in functions {
            if func.reads_states.contains(&var_name.to_string()) {
                direct.push(func.name.clone());
            }
        }

        // Find indirect readers (functions that call direct readers)
        for func in functions {
            if !direct.contains(&func.name) {
                if let Some(chain) = Self::find_call_chain_to_readers(&func.name, &direct, call_graph) {
                    indirect.push((func.name.clone(), chain));
                }
            }
        }

        (direct, indirect)
    }

    /// Find call chain from caller to any writer
    fn find_call_chain_to_writers(
        caller: &str,
        writers: &[String],
        call_graph: &HashMap<String, Vec<String>>,
    ) -> Option<Vec<String>> {
        Self::find_call_chain_to_targets(caller, writers, call_graph)
    }

    /// Find call chain from caller to any reader
    fn find_call_chain_to_readers(
        caller: &str,
        readers: &[String],
        call_graph: &HashMap<String, Vec<String>>,
    ) -> Option<Vec<String>> {
        Self::find_call_chain_to_targets(caller, readers, call_graph)
    }

    /// Generic function to find call chain to any target function
    fn find_call_chain_to_targets(
        start: &str,
        targets: &[String],
        call_graph: &HashMap<String, Vec<String>>,
    ) -> Option<Vec<String>> {
        let mut visited = HashSet::new();
        let mut queue = vec![(start.to_string(), vec![])];

        while let Some((current, path)) = queue.pop() {
            if visited.contains(&current) {
                continue;
            }
            visited.insert(current.clone());

            if let Some(callees) = call_graph.get(&current) {
                for callee in callees {
                    if targets.contains(callee) {
                        let mut chain = path.clone();
                        chain.push(callee.clone());
                        return Some(chain);
                    }

                    let mut new_path = path.clone();
                    new_path.push(callee.clone());
                    queue.push((callee.clone(), new_path));
                }
            }
        }

        None
    }

    /// Build call graph: function -> list of functions it calls
    fn build_call_graph(functions: &[FunctionDef]) -> HashMap<String, Vec<String>> {
        let mut graph = HashMap::new();

        for func in functions {
            // Use the calls_functions field which already tracks internal function calls
            if !func.calls_functions.is_empty() {
                graph.insert(func.name.clone(), func.calls_functions.clone());
            }
        }

        graph
    }

    /// Get function visibility
    fn get_func_visibility(func_name: &str, functions: &[FunctionDef]) -> String {
        functions
            .iter()
            .find(|f| f.name == func_name)
            .map(|f| f.visibility.clone())
            .unwrap_or_else(|| "unknown".to_string())
    }
}
