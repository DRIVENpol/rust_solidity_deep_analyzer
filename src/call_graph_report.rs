use crate::models::*;
use std::collections::{HashMap, HashSet};

pub struct CallGraphReportGenerator;

impl CallGraphReportGenerator {
    /// Generate function call graph report for all contracts
    pub fn generate_report(contracts: &[ContractInfo]) -> String {
        let mut report = String::new();

        report.push_str("# Function Call Graph Report\n\n");
        report.push_str("**Shows all internal and external function calls within each contract**\n\n");

        for contract in contracts {
            report.push_str(&Self::generate_contract_section(contract, contracts));
        }

        report.push_str("\n---\n\n");
        report.push_str("*Generated by MainnetReady - Solidity Enhanced Analyzer*\n");

        report
    }

    /// Generate section for a single contract
    fn generate_contract_section(contract: &ContractInfo, all_contracts: &[ContractInfo]) -> String {
        let mut section = String::new();

        section.push_str("‚ïê".repeat(80).as_str());
        section.push('\n');
        section.push_str(&format!("## Contract: {}\n", contract.name));
        section.push_str("‚ïê".repeat(80).as_str());
        section.push_str("\n\n");

        // Section 1: External Calls
        section.push_str(&Self::generate_external_calls_section(contract, all_contracts));

        // Section 2: Internal Call Graph
        section.push_str(&Self::generate_internal_call_graph_section(contract));

        section.push('\n');
        section
    }

    /// Generate external calls section
    fn generate_external_calls_section(contract: &ContractInfo, _all_contracts: &[ContractInfo]) -> String {
        let mut section = String::new();

        section.push_str("### üìû External Contract Calls\n\n");

        // Group external calls by calling function
        let mut calls_by_function: HashMap<String, Vec<&ExternalCall>> = HashMap::new();

        for func in &contract.functions {
            if !func.external_calls.is_empty() {
                calls_by_function.insert(func.name.clone(), func.external_calls.iter().collect());
            }
        }

        if calls_by_function.is_empty() {
            section.push_str("*No external calls detected*\n\n");
        } else {
            for (func_name, calls) in calls_by_function.iter() {
                let func = contract.functions.iter().find(|f| &f.name == func_name).unwrap();
                section.push_str(&format!("**From `{}()`** *({})*:\n", func_name, func.visibility));

                for call in calls {
                    let target_interface = call.target_contract.as_ref()
                        .map(|s| format!(" *[{}]*", s))
                        .unwrap_or_default();

                    let target_var = if call.target_variable.is_empty() {
                        "<unknown>".to_string()
                    } else {
                        call.target_variable.clone()
                    };

                    section.push_str(&format!("   - ‚Üí `{}.{}()`{}\n",
                        target_var, call.target_function, target_interface));
                }
                section.push('\n');
            }
        }

        section
    }

    /// Generate internal call graph section
    fn generate_internal_call_graph_section(contract: &ContractInfo) -> String {
        let mut section = String::new();

        section.push_str("### üîó Internal Call Graph\n\n");
        section.push_str("*Shows the hierarchy of internal function calls*\n\n");

        // Build internal call graph
        let call_graph = Self::build_internal_call_graph(&contract.functions);

        // Find root functions (external/public functions)
        let mut root_functions: Vec<&FunctionDef> = contract
            .functions
            .iter()
            .filter(|f| matches!(f.visibility.as_str(), "external" | "public"))
            .collect();

        // Sort by name for consistent output
        root_functions.sort_by(|a, b| a.name.cmp(&b.name));

        if root_functions.is_empty() {
            section.push_str("*No public/external functions detected*\n\n");
            return section;
        }

        for root in root_functions {
            section.push_str(&Self::generate_call_tree(&root.name, &call_graph, &contract.functions, 0, &mut HashSet::new()));
            section.push('\n');
        }

        // Show internal functions that are never called (orphaned)
        let called_functions: HashSet<String> = call_graph
            .values()
            .flat_map(|v| v.iter().cloned())
            .collect();

        let orphaned: Vec<&FunctionDef> = contract
            .functions
            .iter()
            .filter(|f| !matches!(f.visibility.as_str(), "external" | "public") && !called_functions.contains(&f.name))
            .collect();

        if !orphaned.is_empty() {
            section.push_str("**‚ö†Ô∏è  Orphaned Internal Functions** *(never called)*:\n");
            for func in orphaned {
                section.push_str(&format!("   - `{}` *({})*\n", func.name, func.visibility));
            }
            section.push('\n');
        }

        section
    }

    /// Generate call tree recursively
    fn generate_call_tree(
        func_name: &str,
        call_graph: &HashMap<String, Vec<String>>,
        all_functions: &[FunctionDef],
        depth: usize,
        visited: &mut HashSet<String>,
    ) -> String {
        let mut tree = String::new();

        // Get function details
        let func = all_functions.iter().find(|f| f.name == func_name);
        let visibility = func.map(|f| f.visibility.as_str()).unwrap_or("unknown");

        // Indentation
        let indent = if depth == 0 {
            "".to_string()
        } else {
            "   ".repeat(depth - 1) + "   "
        };


        // Function name with visibility
        tree.push_str(&format!("{}`{}()`** *({})***\n",
            indent,
            func_name,
            visibility
        ));

        // Check for recursion
        if visited.contains(func_name) {
            tree.push_str(&format!("{}   ‚îî‚îÄ> ‚ö†Ô∏è  *Recursive call detected*\n", indent));
            return tree;
        }

        visited.insert(func_name.to_string());

        // Get callees
        if let Some(callees) = call_graph.get(func_name) {
            for (i, callee) in callees.iter().enumerate() {
                let is_last = i == callees.len() - 1;
                let new_indent = if depth == 0 {
                    "   ".to_string()
                } else {
                    format!("{}   ", indent)
                };

                let callee_vis = all_functions
                    .iter()
                    .find(|f| &f.name == callee)
                    .map(|f| f.visibility.as_str())
                    .unwrap_or("unknown");

                tree.push_str(&format!("{}{} `{}()` *({})*\n",
                    new_indent,
                    if is_last { "‚îî‚îÄ>" } else { "‚îú‚îÄ>" },
                    callee,
                    callee_vis
                ));

                // Recursively show nested calls
                if let Some(nested_callees) = call_graph.get(callee) {
                    if !nested_callees.is_empty() && !visited.contains(callee) {
                        let mut sub_visited = visited.clone();
                        let subtree = Self::generate_call_tree_subtree(
                            callee,
                            call_graph,
                            all_functions,
                            depth + 2,
                            &mut sub_visited,
                            is_last
                        );
                        tree.push_str(&subtree);
                    }
                }
            }
        }

        visited.remove(func_name);
        tree
    }

    /// Generate subtree for nested calls
    fn generate_call_tree_subtree(
        func_name: &str,
        call_graph: &HashMap<String, Vec<String>>,
        all_functions: &[FunctionDef],
        depth: usize,
        visited: &mut HashSet<String>,
        parent_is_last: bool,
    ) -> String {
        let mut tree = String::new();

        if visited.contains(func_name) {
            return tree;
        }

        visited.insert(func_name.to_string());

        if let Some(callees) = call_graph.get(func_name) {
            for (i, callee) in callees.iter().enumerate() {
                let is_last = i == callees.len() - 1;

                let indent = "   ".repeat(depth);
                let connector = if parent_is_last { " " } else { "‚îÇ" };

                let callee_vis = all_functions
                    .iter()
                    .find(|f| &f.name == callee)
                    .map(|f| f.visibility.as_str())
                    .unwrap_or("unknown");

                tree.push_str(&format!("{}{}   {} `{}()` *({})*\n",
                    indent,
                    connector,
                    if is_last { "‚îî‚îÄ>" } else { "‚îú‚îÄ>" },
                    callee,
                    callee_vis
                ));

                // Recursively show deeper nested calls
                if let Some(nested_callees) = call_graph.get(callee) {
                    if !nested_callees.is_empty() && !visited.contains(callee) {
                        let subtree = Self::generate_call_tree_subtree(
                            callee,
                            call_graph,
                            all_functions,
                            depth + 1,
                            visited,
                            is_last
                        );
                        tree.push_str(&subtree);
                    }
                }
            }
        }

        tree
    }

    /// Build internal call graph from function data
    fn build_internal_call_graph(functions: &[FunctionDef]) -> HashMap<String, Vec<String>> {
        let mut graph: HashMap<String, Vec<String>> = HashMap::new();

        for func in functions {
            // Use the calls_functions field which already tracks internal function calls
            if !func.calls_functions.is_empty() {
                graph.insert(func.name.clone(), func.calls_functions.clone());
            }
        }

        graph
    }
}
