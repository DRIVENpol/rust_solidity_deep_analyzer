use crate::models::*;
use serde_json::{json, Value};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

// Type alias for contract interaction mappings
type InteractionMap = HashMap<(String, String), Vec<(String, String, String)>>;

// Type alias for cross-contract state dependencies
// (source_contract, source_function, target_contract, target_function, is_modification, modifies_states, reads_states)
type StateDependency = (String, String, String, String, bool, Vec<String>, Vec<String>);

pub struct ContractInteractionReports;

impl ContractInteractionReports {
    /// Generate markdown report for contract interactions
    /// Shows which contracts call which other contracts and what functions they invoke
    pub fn generate_contract_interactions_md(contracts: &[ContractInfo]) -> String {
        let mut md = String::new();

        md.push_str("# Contract Interaction Report\n\n");
        md.push_str("**Shows how contracts interact with each other through function calls**\n\n");
        md.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

        // Build interaction map: (source_contract, target_contract) -> Vec<(function_name, target_function)>
        let mut interactions: InteractionMap = HashMap::new();

        for contract in contracts {
            for func in &contract.functions {
                for ext_call in &func.external_calls {
                    if let Some(ref target_contract) = ext_call.target_contract {
                        if target_contract != &contract.name {
                            let key = (contract.name.clone(), target_contract.clone());
                            interactions.entry(key)
                                .or_default()
                                .push((
                                    func.name.clone(),
                                    ext_call.target_function.clone(),
                                    ext_call.state_mutability.clone()
                                ));
                        }
                    }
                }
            }
        }

        if interactions.is_empty() {
            md.push_str("*No cross-contract interactions detected*\n");
            return md;
        }

        // Sort by source contract name
        let mut sorted_interactions: Vec<_> = interactions.iter().collect();
        sorted_interactions.sort_by_key(|(k, _)| &k.0);

        for ((source, target), calls) in sorted_interactions {
            md.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
            md.push_str(&format!("## ğŸ“‹ {} â†’ {}\n", source, target));
            md.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
            md.push_str(&format!("**{} total function calls**\n\n", calls.len()));

            // Group by source function
            let mut grouped: HashMap<String, Vec<(String, String)>> = HashMap::new();
            for (src_func, target_func, mutability) in calls {
                grouped.entry(src_func.clone())
                    .or_default()
                    .push((target_func.clone(), mutability.clone()));
            }

            let mut sorted_funcs: Vec<_> = grouped.iter().collect();
            sorted_funcs.sort_by_key(|(k, _)| *k);

            for (i, (src_func, target_calls)) in sorted_funcs.iter().enumerate() {
                if i > 0 {
                    md.push_str("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n");
                }
                md.push_str(&format!("### ğŸ”¹ `{}()`\n\n", src_func));
                md.push_str("**Calls:**\n");

                for (target_func, mutability) in *target_calls {
                    let icon = match mutability.as_str() {
                        "view" | "pure" => "ğŸ”",
                        "payable" => "ğŸ’°",
                        _ => "âœï¸",
                    };
                    md.push_str(&format!("  - {} `{}()` *[{}]*\n", icon, target_func, mutability));
                }
                md.push('\n');
            }

            md.push('\n');
        }

        md.push_str("\n---\n\n");
        md.push_str("*Generated by MainnetReady - Solidity Enhanced Analyzer*\n");

        md
    }

    /// Generate JSON report for contract interactions
    pub fn generate_contract_interactions_json(contracts: &[ContractInfo]) -> Value {
        let mut interactions: HashMap<String, HashMap<String, Vec<Value>>> = HashMap::new();

        for contract in contracts {
            for func in &contract.functions {
                for ext_call in &func.external_calls {
                    if let Some(ref target_contract) = ext_call.target_contract {
                        if target_contract != &contract.name {
                            let call_info = json!({
                                "source_function": func.name,
                                "source_function_visibility": func.visibility,
                                "target_function": ext_call.target_function,
                                "target_function_mutability": ext_call.state_mutability,
                                "line_number": ext_call.line_number
                            });

                            interactions.entry(contract.name.clone())
                                .or_default()
                                .entry(target_contract.clone())
                                .or_default()
                                .push(call_info);
                        }
                    }
                }
            }
        }

        json!(interactions)
    }

    /// Generate markdown report for cross-contract state dependencies
    pub fn generate_cross_contract_state_dependencies_md(contracts: &[ContractInfo]) -> String {
        let mut md = String::new();

        md.push_str("# Cross-Contract State Variable Dependencies\n\n");
        md.push_str("**Shows how functions in one contract access/modify state variables in other contracts**\n\n");
        md.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

        // Collect all cross-contract state dependencies
        let mut dependencies: Vec<StateDependency> = Vec::new();

        for contract in contracts {
            for func in &contract.functions {
                for ext_call in &func.external_calls {
                    if let Some(ref target_contract) = ext_call.target_contract {
                        if target_contract != &contract.name {
                            // Check if this call modifies or reads state
                            let has_modifications = !ext_call.target_modifies_states.is_empty();
                            let has_reads = !ext_call.target_reads_states.is_empty();

                            if has_modifications || has_reads {
                                dependencies.push((
                                    contract.name.clone(),
                                    func.name.clone(),
                                    target_contract.clone(),
                                    ext_call.target_function.clone(),
                                    has_modifications,
                                    ext_call.target_modifies_states.clone(),
                                    ext_call.target_reads_states.clone(),
                                ));
                            }
                        }
                    }
                }
            }
        }

        if dependencies.is_empty() {
            md.push_str("*No cross-contract state dependencies detected*\n");
            return md;
        }

        // Group by source contract
        let mut by_contract: HashMap<String, Vec<_>> = HashMap::new();
        for dep in dependencies {
            by_contract.entry(dep.0.clone()).or_default().push(dep);
        }

        let mut sorted_contracts: Vec<_> = by_contract.keys().collect();
        sorted_contracts.sort();

        for source_contract in sorted_contracts {
            let deps = by_contract.get(source_contract).unwrap();

            md.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
            md.push_str(&format!("## ğŸ“¦ {} (Source Contract)\n", source_contract));
            md.push_str("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

            // Group by target contract
            let mut by_target: HashMap<String, Vec<_>> = HashMap::new();
            for dep in deps {
                by_target.entry(dep.2.clone()).or_default().push(dep);
            }

            let mut sorted_targets: Vec<_> = by_target.keys().collect();
            sorted_targets.sort();

            for (target_idx, target_contract) in sorted_targets.iter().enumerate() {
                if target_idx > 0 {
                    md.push_str("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n");
                }

                let target_deps = by_target.get(*target_contract).unwrap();

                md.push_str(&format!("### ğŸ¯ Target: **{}**\n\n", target_contract));

                for (call_idx, (_, src_func, _, target_func, _has_mods, modifies, reads)) in target_deps.iter().enumerate() {
                    if call_idx > 0 {
                        md.push_str("   â•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œâ•Œ\n\n");
                    }

                    md.push_str(&format!("#### ğŸ”— `{}.{}()` â†’ `{}.{}()`\n\n",
                        source_contract, src_func, target_contract, target_func));

                    if !modifies.is_empty() {
                        md.push_str("   âœï¸  **Modifies State Variables:**\n");
                        for var in modifies {
                            md.push_str(&format!("      - `{}.{}`\n", target_contract, var));
                        }
                        md.push('\n');
                    }

                    if !reads.is_empty() {
                        md.push_str("   ğŸ” **Reads State Variables:**\n");
                        for var in reads {
                            md.push_str(&format!("      - `{}.{}`\n", target_contract, var));
                        }
                        md.push('\n');
                    }
                }

                md.push('\n');
            }

            md.push('\n');
        }

        md.push_str("\n---\n\n");
        md.push_str("*Generated by MainnetReady - Solidity Enhanced Analyzer*\n");

        md
    }

    /// Generate JSON report for cross-contract state dependencies
    pub fn generate_cross_contract_state_dependencies_json(contracts: &[ContractInfo]) -> Value {
        let mut dependencies: HashMap<String, HashMap<String, Vec<Value>>> = HashMap::new();

        for contract in contracts {
            for func in &contract.functions {
                for ext_call in &func.external_calls {
                    if let Some(ref target_contract) = ext_call.target_contract {
                        if target_contract != &contract.name {
                            let has_modifications = !ext_call.target_modifies_states.is_empty();
                            let has_reads = !ext_call.target_reads_states.is_empty();

                            if has_modifications || has_reads {
                                let dep_info = json!({
                                    "source_function": func.name,
                                    "source_function_visibility": func.visibility,
                                    "target_function": ext_call.target_function,
                                    "target_function_mutability": ext_call.state_mutability,
                                    "modifies_state_variables": ext_call.target_modifies_states,
                                    "reads_state_variables": ext_call.target_reads_states,
                                    "line_number": ext_call.line_number
                                });

                                dependencies.entry(contract.name.clone())
                                    .or_default()
                                    .entry(target_contract.clone())
                                    .or_default()
                                    .push(dep_info);
                            }
                        }
                    }
                }
            }
        }

        json!(dependencies)
    }

    /// Save JSON to file
    pub fn save_json(json_data: &Value, output_path: &Path) -> anyhow::Result<()> {
        let json_string = serde_json::to_string_pretty(json_data)?;
        fs::write(output_path, json_string)?;
        Ok(())
    }
}
