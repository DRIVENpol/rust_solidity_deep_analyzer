# Cross-Contract Call Analysis

## Cross-Contract Call Chains

`JackpotBridgeManager.claimWinnings()`
   └─> `jackpot.claimWinnings()` [IJackpot → Jackpot]
          `└─> jackpotNFT.burnTicket()` [IJackpotTicketNFT → JackpotTicketNFT]
          `└─> usdc.safeTransfer()` [IERC20]

`Jackpot.claimWinnings()`
   └─> `jackpotNFT.burnTicket()` [IJackpotTicketNFT → JackpotTicketNFT]

`Jackpot.lpDeposit()`
   └─> `jackpotLPManager.processDeposit()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpInfo`, `lpDrawingState`
          └─> also modified by: `processInitiateWithdraw`, `processFinalizeWithdraw`, `emergencyWithdrawLP`, `initializeDrawingLP`
          `└─> _consolidateDeposits` (internal)

`Jackpot.initiateWithdraw()`
   └─> `jackpotLPManager.processInitiateWithdraw()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpDrawingState`, `lpInfo`
          └─> also modified by: `processDeposit`, `emergencyWithdrawLP`, `initializeDrawingLP`, `processFinalizeWithdraw`
          `└─> _consolidateWithdrawals` (internal)
          `└─> _consolidateDeposits` (internal)

`Jackpot.emergencyRefundTickets()`
   └─> `jackpotNFT.burnTicket()` [IJackpotTicketNFT → JackpotTicketNFT]

`Jackpot.initializeLPDeposits()`
   └─> `jackpotLPManager.initializeLP()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `drawingAccumulator`
          └─> also modified by: `processDrawingSettlement`

`Jackpot.initializeLPDeposits()`
   └─> `jackpotLPManager.setLPPoolCap()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpPoolCap`

`Jackpot.setNormalBallMax()`
   └─> `jackpotLPManager.setLPPoolCap()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpPoolCap`

`Jackpot.setGovernancePoolCap()`
   └─> `jackpotLPManager.setLPPoolCap()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpPoolCap`

`Jackpot.setLpEdgeTarget()`
   └─> `jackpotLPManager.setLPPoolCap()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpPoolCap`

`Jackpot.setReserveRatio()`
   └─> `jackpotLPManager.setLPPoolCap()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpPoolCap`

`Jackpot.setTicketPrice()`
   └─> `jackpotLPManager.setLPPoolCap()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpPoolCap`

`Jackpot._setNewDrawingState()`
   └─> `jackpotLPManager.initializeDrawingLP()` [IJackpotLPManager → JackpotLPManager]
          └─> modifies: `lpDrawingState`
          └─> also modified by: `processDeposit`, `processInitiateWithdraw`, `emergencyWithdrawLP`

`Jackpot._setNewDrawingState()`
   └─> `payoutCalculator.setDrawingTierInfo()` [IPayoutCalculator → IPayoutCalculator]

`Jackpot._validateAndStoreTickets()`
   └─> `jackpotNFT.mintTicket()` [IJackpotTicketNFT → JackpotTicketNFT]
          └─> modifies: `tickets`


## State Variables with Multiple Entry Points

The following state variables can be modified through multiple cross-contract call paths, which may indicate important access control patterns:

`lpPoolCap` in contract `JackpotLPManager`
   6 entry point(s):
      ├─ `Jackpot.initializeLPDeposits()` → `setLPPoolCap()`
      ├─ `Jackpot.setNormalBallMax()` → `setLPPoolCap()`
      ├─ `Jackpot.setGovernancePoolCap()` → `setLPPoolCap()`
      ├─ `Jackpot.setLpEdgeTarget()` → `setLPPoolCap()`
      ├─ `Jackpot.setReserveRatio()` → `setLPPoolCap()`
      ├─ `Jackpot.setTicketPrice()` → `setLPPoolCap()`

`lpDrawingState` in contract `JackpotLPManager`
   3 entry point(s):
      ├─ `Jackpot.lpDeposit()` → `processDeposit()`
      ├─ `Jackpot.initiateWithdraw()` → `processInitiateWithdraw()`
      ├─ `Jackpot._setNewDrawingState()` → `initializeDrawingLP()`

`lpInfo` in contract `JackpotLPManager`
   2 entry point(s):
      ├─ `Jackpot.lpDeposit()` → `processDeposit()`
      ├─ `Jackpot.initiateWithdraw()` → `processInitiateWithdraw()`


---

*Generated by MainnetReady - Solidity Enhanced Analyzer*
